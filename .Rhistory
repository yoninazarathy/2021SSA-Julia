data = runif(10)
data = runif(10)
data = runif(10)
for(i in 1:10){
print(i)
}
data = runif(200)
data
x = 24
x
length(x)
data[194]
help("matrix")
emp.data <- data.frame(
emp_id = c (1:5),
emp_name = c("Rick","Dan","Michelle","Ryan","Gary"),
salary = c(623.3,515.2,611.0,729.0,843.25),
start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",
"2015-03-27")),
stringsAsFactors = FALSE
)
emp.data
plot(emp.data)
x <- 27
x
x = 27
x
27 -> x
x
"Hi People"
s = "Hi People"
class(s)
# comments
# comments
# comments
# comments
# comments
FALSE
TRUE
TRUE || FALSE
myAge = 47
myAge < 40 || myAge > 60
myAge = 57
myAge < 40 || myAge > 60
myAge = 67
myAge < 40 || myAge > 60
my.age = 47
help(c)
myFriendsNumbers = c(24,235,89,-9.5)
myFriendsNumbers
var_x <- "Hello"
cat("The class of var_x is ",class(var_x),"\n")
cat("Cat","Dog")
ls()
1:10
myNums = 1:10
0:9
1:10 + 101:110
1:10 + 101:115
ans = 1:10 + 101:115
ans
ans = 25
ans/0
2^5
2**5
2+7 == 10-1
2+7 = 10-1
myVar = 2+7
myVar == 10-1
myVar = 10-1
myVar
if(2**5 == 32){
print("yes")
}
if(2**5 == 33){
print("yes")
}
if(2**5 == 33){
print("yes")
}else{
print("now way")
}
if(2**5 == 32){
print("yes")
}else{
print("now way")
}
if(2**5 == 33){
print("yes")
}else{
print("now way")
}
repeat{
print("I love R")
}
i = 0
repeat{
i = i +1
print("I love R")
if(i==10){
break
}
}
i = 0
while(TRUE){
i = i + 1
print("I love R")
if(i==10){
break
}
}
i = 0
while(i < 10){
i = i + 1
print("I love R")
# if(i==10){
#   break
# }
}
myKids = c("Yarden","Emily","Kayley")
myKids = c("Yarden","Emily","Kayley")
for(k in myKids){
cat("I love", k)
}
myKids = c("Yarden","Emily","Kayley")
for(k in myKids){
cat("I love", k,"\n")
}
addThem <- function(a,b){
a+b
}
addThem(10,5)
addThem(addThem(2,4),-8)
for(i in 1:10){
print(i)
}
data = runif(10)
data
addThem <- function(a,b){
print("Listen guys, I am just about to do addition.....")
a+b
}
addThem(2,3)
data
help(min)
min(data)
data = runif(1000)
min(data)
Inf
myMin <- function(input_data){
bestMin = Inf
for(d in input_data){
if(d < bestMin){
bestMin <- d  #found new minimum
}
}
bestMin
}
bestMin(data)
myMin(data)
min(data)
# Create a sequence of numbers between -10 and 10 incrementing by 0.1.
x <- seq(-10, 10, by = .1)
# Choose the mean as 2.5 and standard deviation as 0.5.
y <- dnorm(x, mean = 2.5, sd = 0.5)
# Give the chart file a name.
png(file = "dnorm.png")
plot(x,y)
# Save the file.
dev.off()
# Create a sequence of numbers between -10 and 10 incrementing by 0.1.
x <- seq(-10, 10, by = .1)
# Choose the mean as 2.5 and standard deviation as 0.5.
y <- dnorm(x, mean = 2.5, sd = 0.5)
plot(x,y)
x <- seq(-10, 10, by = .05)
y <- dnorm(x, mean = 2.5, sd = 0.5)
plot(x,y)
x <- seq(-0, 5, by = .05)
y <- dnorm(x, mean = 2.5, sd = 0.5)
plot(x,y)
?pnorm
pnorm(1.96)
qnorm(0.975)
X <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3vs8_matrix_train.csv"))
X
size(X)
A <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3vs8_matrix_train.csv"))
A$Column1
A$Column2
A <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3vs8_matrix_train.csv"))
y <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/y_3vs8_vector_train.csv"))
y
A
t(A)
inv(t(A)*A)
history
A3test <- <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3_test.csv"))
#Download training design matrix and labels
A <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3vs8_matrix_train.csv"))
y <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/y_3vs8_vector_train.csv"))
#Download testing design matrix (each row is an image) for the digit "3" (positive)
A3test <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3_test.csv"))
#Download testing design matrix (each row is an image) for the digit "8" (negative)
A8test <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_8_test.csv"))
A8test
#Download training design matrix and labels
A <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3vs8_matrix_train.csv"))
#ML in 180 Minutes group/self exercise...
#Download training design matrix and labels
A <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3vs8_matrix_train.csv"))
y <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/y_3vs8_vector_train.csv"))
#Download testing design matrix (each row is an image) for the digit "3" (positive)
A3test <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3_test.csv"))
#Download testing design matrix (each row is an image) for the digit "8" (negative)
A8test <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_8_test.csv"))
#Task 1: Finding the least squares beta based on A and y.
#Taks 1a: Do this via the pseudoinverse, or GLM, or similar.
#Task 1b: Do this via an iterative gradient descent implementation
#Task 2: Evaluate the accuracy of the estimator(s) from task 1 on the accuracy
pseudoinverse
library("corpor")
library("corpcor")
install.packages("corpor")
library("corpcor")
install.packages("pracma")
library("pracma")
pinv(A)
#ML in 180 Minutes group/self exercise...
#Download training design matrix and labels
A <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3vs8_matrix_train.csv"))
y <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/y_3vs8_vector_train.csv"))
#Download testing design matrix (each row is an image) for the digit "3" (positive)
A3test <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_3_test.csv"))
#Download testing design matrix (each row is an image) for the digit "8" (negative)
A8test <- read.csv(url("https://raw.githubusercontent.com/yoninazarathy/MathematicalEngineeringDeepLearning/master/ML180Minutes/A_8_test.csv"))
#Task 1: Finding the least squares beta based on A and y.
#Taks 1a: Do this via the pseudoinverse, or GLM, or similar.
#Task 1b: Do this via an iterative gradient descent implementation
#Task 2: Evaluate the accuracy of the estimator(s) from task 1 on the accuracy
A
Amat = as.matrix(A)
Amat
:20){
print(i)
}
for(i in 1:20){
print(i)
}
beta = runif(785)
y
for(i in 1:2){
grad = 2*t(Amat)%*%(Amat%*%beta-y)
print(grad)
}
eta <- 0.001
Amat = as.matrix(A)
ymat = as.matrix(y)
beta = runif(785) #initial guess
for(i in 1:2){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat)
print(grad)
}
help norm
eta <- 0.001
Amat = as.matrix(A)
ymat = as.matrix(y)
beta = runif(785) #initial guess
for(i in 1:2){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
eta <- 0.001
Amat = as.matrix(A)
ymat = as.matrix(y)
beta = runif(785) #initial guess
for(i in 1:100){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
eta <- 0.00001
Amat = as.matrix(A)
ymat = as.matrix(y)
beta = runif(785) #initial guess
for(i in 1:100){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
eta <- 0.00001
Amat = as.matrix(A)
ymat = as.matrix(y)
beta = rep(0,785)#runif(785) #initial guess
for(i in 1:100){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
Atest = matrix(c(1, 2.3, 1, 2.7, 1, 3.2, 1, 4.5),ncol=2)
Atest
Atest = matrix(c(1, 2.3, 1, 2.7, 1, 3.2, 1, 4.5),ncol=2,byrows=FALSE)
Atest = matrix(c(1, 2.3, 1, 2.7, 1, 3.2, 1, 4.5),ncol=2,byrow=FALSE)
Atest
Atest = matrix(c(1, 2.3, 1, 2.7, 1, 3.2, 1, 4.5),ncol=2,byrow=TRUE)
Atest = matrix(c(1, 2.3, 1, 2.7, 1, 3.2, 1, 4.5),ncol=2,byrow=TRUE)
Atest = matrix(c(1, 2.3, 1, 2.7, 1, 3.2, 1, 4.5),ncol=2,byrow=TRUE)
Atest
eta <- 0.00001
Amat = Atest#as.matrix(A)
ymat = ytest#as.matrix(y)
beta = rep(0,785)#runif(785) #initial guess
for(i in 1:100){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
Atest = matrix(c(1, 2.3, 1, 2.7, 1, 3.2, 1, 4.5),ncol=2,byrow=TRUE)
ytest = c(2,3,4,5)
eta <- 0.00001
Amat = Atest#as.matrix(A)
ymat = ytest#as.matrix(y)
beta = rep(0,785)#runif(785) #initial guess
for(i in 1:100){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
Atest = matrix(c(1, 2.3, 1, 2.7, 1, 3.2, 1, 4.5),ncol=2,byrow=TRUE)
ytest = c(2,3,4,5)
eta <- 0.00001
Amat = Atest#as.matrix(A)
ymat = ytest#as.matrix(y)
beta = rep(0,2)#runif(785) #initial guess
for(i in 1:100){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
eta <- 0.001
eta <- 0.001
Amat = Atest#as.matrix(A)
ymat = ytest#as.matrix(y)
beta = rep(0,2)#runif(785) #initial guess
for(i in 1:100){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
beta
lm(ytest~Atest[,2])
Atest = matrix(c(1, 2.3, 1, 2.7, 1, 3.2, 1, 4.5),ncol=2,byrow=TRUE)
ytest = c(2,3,4,5)
eta <- 0.001
Amat = Atest#as.matrix(A)
ymat = ytest#as.matrix(y)
beta = rep(0,2)#runif(785) #initial guess
for(i in 1:1000){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
print(beta)
lm(ytest~Atest[,2])
eta <- 0.0001
Amat = Atest#as.matrix(A)
ymat = ytest#as.matrix(y)
beta = rep(0,2)#runif(785) #initial guess
for(i in 1:1000){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
print(beta)
lm(ytest~Atest[,2])
eta <- 0.0001
Amat = Atest#as.matrix(A)
ymat = ytest#as.matrix(y)
beta = rep(0,2)#runif(785) #initial guess
for(i in 1:10000){
grad = 2*t(Amat)%*%(Amat%*%beta-ymat) #gradient computation from closed form formula
beta = beta - eta*grad #simple gradient descent step
err = norm(Amat%*%beta - ymat)^2
print(err)
}
print(beta)
lm(ytest~Atest[,2])
library("JuliaCall")
library(JuliaCall)
julia_setup(JULIA_HOME = "/Applications/Julia-1.6.app/Contents/Resources/julia/bin/julia")
julia_setup(JULIA_HOME = "/Applications/Julia-1.6.app/Contents/Resources/julia/bin/julia.exe")
julia_setup(JULIA_HOME = "/Applications/Julia-1.5.app/Contents/Resources/julia/bin")
julia_command("a = sqrt(2);"); julia_eval("a")
library(JuliaCall)
julia_installed_package("Distributions")
julia_setup(JULIA_HOME = "/Applications/Julia-1.5.app/Contents/Resources/julia/bin")
julia_command("a = sqrt(2);"); julia_eval("a")
setwd("~/git/mine/2021SSA-Julia/")
file.show()
julia_help("sqrt")
julia_console()
julia_console()
#install.packages("JuliaCall")
library(JuliaCall)
#julia_setup(JULIA_HOME = "/Applications/Julia-1.5.app/Contents/Resources/julia/bin")
#julia <- julia_setup()
#julia_command("a = sqrt(2);"); julia_eval("a")
getwd()
setwd("~/git/mine/2021SSA-Julia/")
julia_command("include(\"simulation.jl\")")
julia_command("include(\"simulation.jl\")")
julia_command("include(\"simulation.jl\");")
julia_command("init_params();")
julia_command("run_sim()")
results <- julia_command("run_sim()")
results$time_range
results.time_range
results
results <- julia_eval("run_sim()")
results
results <- julia_eval("run_sim()",need_return="R")
results <- julia_eval("run_sim()",need_return="R")
results
results <- julia_eval("run_sim()",need_return="R")
results
results$.(... = ...)
results$id
results$.(time_range)
results$time_range
results$count_S
results$counts_S
plot(results$counts_I)
plot(results$counts_I,results$counts_S)
plot(results$counts_I)
> plot(results$time_range,results$counts_I)
plot(results$time_range,results$counts_I)
plot(results$time_range,results$counts_R)
results <- julia_eval("run_sim()",need_return="R")
plot(results$time_range,results$counts_R)
#install.packages("JuliaCall")
library(JuliaCall)
#julia_setup(installJulia = TRUE)
#julia_setup(JULIA_HOME = "/Applications/Julia-1.5.app/Contents/Resources/julia/bin")
getwd()
setwd("~/git/mine/2021SSA-Julia/")
julia_command("include(\"simulation.jl\");")
julia_command("init_params();")
results <- julia_eval("run_sim()",need_return="R")
plot(results$time_range,results$counts_R)
for(i in 1;10){
results <- julia_eval("run_sim()",need_return="R")
plot(results$time_range,results$counts_R)
}
10){
results <- julia_eval("run_sim()",need_return="R")
plot(results$time_range,results$counts_R)
}
10){
results <- julia_eval("run_sim()",need_return="R")
plot(results$time_range,results$counts_R)
}
#install.packages("JuliaCall")
library(JuliaCall)
#julia_setup(installJulia = TRUE)
#julia_setup(JULIA_HOME = "/Applications/Julia-1.5.app/Contents/Resources/julia/bin")
getwd()
setwd("~/git/mine/2021SSA-Julia/")
julia_command("include(\"simulation.jl\");")
julia_command("init_params();")
for(i in 1:10){
results <- julia_eval("run_sim()",need_return="R")
plot(results$time_range,results$counts_R)
}
for(i in 1:10){
results <- julia_eval("run_sim()",need_return="R")
plot(results$time_range,results$counts_I)
}
#install.packages("JuliaCall")
library(JuliaCall)
#julia_setup(installJulia = TRUE)
#julia_setup(JULIA_HOME = "/Applications/Julia-1.5.app/Contents/Resources/julia/bin")
getwd()
setwd("~/git/mine/2021SSA-Julia/")
julia_command("include(\"simulation.jl\");")
julia_command("init_params();")
for(i in 1:10){
results <- julia_eval("run_sim()",need_return="R")
plot(results$time_range,results$counts_I)
}
#install.packages("JuliaCall")
library(JuliaCall)
#julia_setup(installJulia = TRUE)
#julia_setup(JULIA_HOME = "/Applications/Julia-1.5.app/Contents/Resources/julia/bin")
getwd()
setwd("~/git/mine/2021SSA-Julia/")
julia_command("include(\"Minimal-Simulation.jl\");")
julia_command("init_params();")
for(i in 1:3){
results <- julia_eval("run_sim()",need_return="R")
plot(results$time_range,results$counts_I)
}
